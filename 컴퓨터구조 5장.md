># 지역성의 원리
## 프로그램은 언제든지 주소 공간의 작은 부분에 액세스한다.  (지역성, 국지성, 국부성)
## 시간적 지역성
- 최근에 액세스한 항목은 곧 다시 액세스될 가능성이 높다.
- 예를 들어 루프의 명령어
## 공간의 지역성
- 최근에 접근한 항목 근처에 있는 항목은 곧 접근될 가능성이 높다.
- 예를 들어, 순차적 명령어 액세스, 배열 데이터

># 지역성을 활용하다
## 메모리 계층
## 모든 것을 디스크에 저장
## 최근에 액세스한(및 근처의) 항목을 디스크에서 더 작은 DRAM 메모리로 복사한다.
- 메인 메모리
## 최근에 액세스한(그리고 근처에 있는) 항목을 DRAM에서 더 작은 SRAM 메모리로 복사한다.
- CPU에 연결된 캐시 메모리

># 메모리 계층 수준
<img width="296" alt="스크린샷 2024-06-10 오후 2 59 24" src="https://github.com/junhyeok030213/computer-structure/assets/106813806/4cb04216-8a85-4504-a8e2-1e2cf23139cc">

## 블록(일명 라인): 복사 단위
- 여러 단어일 수 있음
## 접근된 데이터가 다음 위치에 있는 경우 상위 레벨
- Hit: 상위레벨에서 접속의 만족됨

  -> 적중률: 조회수/접속수

## 접근한 데이터가 없는 경우
- Miss: 하위 레벨에서 복사된 블록

  -> 소요시간: 미스 페널티

  -> 미스비율: 미스/액세스 = 1 - 적중률

- 그러면 접근된 데이터는 상위에서 공급된다.

># 메모리 기술
## 정적 RAM(SRAM)
- 0.5ns - 2.5ns, GB당 $500 - $1,000
## 동적 RAM(DRAM)
- 40ns - 70ns, GB당 $3 - $6
## 플래시 메모리
- 5μs - 50μs, GB당 $0.06 - $0.12
## 자기 디스크
- 5ms - 20ms, GB당 $0.01 - $0.02
## 이상적인 메모리
- SRAM의 액세스 시간
- 디스크 용량 및 비용/GB

># DRAM 기술
## 커패시터에 전하로 저장된 데이터
- 전하에 접근하는데 사용되는 단일 트랜지스터
- 주기적으로 새로 고쳐야 함

  -> 내용을 읽고 다시 쓰기

  -> DRAM "행"에서 수행됨

<img width="747" alt="스크린샷 2024-06-10 오후 3 10 29" src="https://github.com/junhyeok030213/computer-structure/assets/106813806/a49c3071-09fa-4916-8d19-b96989c34a10">

># 고급 DRAM 구성
## DRAM의 비트는 직사각형 배열로 구성된다.
- DRAM은 전체 행에 액세스한다.
- 버스트 모드: 대기 시간을 줄이면서 연속적인 단어 제공
## 이중 데이터 전송률(DDR) DRAM
- 상승 및 하강 클럭 에지에서 전송
## 쿼드 데이터 속도(QDR) DRAM
- 별도의 DDR 입력 및 출력

># DRAM 세대
<img width="771" alt="스크린샷 2024-06-10 오후 3 13 10" src="https://github.com/junhyeok030213/computer-structure/assets/106813806/bd23ae8b-b6a0-452b-8dfa-fe65f2f99b31">

># DRAM 성능 요소
## 행 버퍼
- 여러 단어를 동시에 읽고 새로 고칠 수 있다.
## 동기식 DRAM
- 각 주소를 보낼 필요 없이 연속적인 액세스를 허용한다.
- 대역폭 향상
## DRAM 뱅킹
- 여러 DRAM에 대한 동시 액세스 허용
- 대역폭 향상

># 메모리 대역폭 늘리기
<img width="730" alt="스크린샷 2024-06-10 오후 3 15 51" src="https://github.com/junhyeok030213/computer-structure/assets/106813806/984d3122-b2bb-40da-8c51-4f5744e393c0">

## 4워드 와이드 메몰 사용
- 미스 페널티 = 1 + 15 + 1 = 17 버스 사이클
- 대역폭 = 16바이트/17사이클 = 0.94 B/cycle
## 4 뱅크 인터리브 메모리
- 미스 페털티 = 1 + 15 + 4 x 1 = 20 버스 사이클
- 대역폭 = 16바이트/20사이클 = 0.8 B/cycle

># 플래시 메모리(스토리지)
## 불휘발성 반도체 메모리(스토리지)
- 디스크보다 100배 - 1000배 빠름
- 더 작고, 더 낮은 전력,더 견고함
- 하지만 $/GB(디스크와 DRAM 간)가 더 높다.
<img width="547" alt="스크린샷 2024-06-10 오후 3 20 25" src="https://github.com/junhyeok030213/computer-structure/assets/106813806/e3a9b072-ec81-42a4-8454-a9f360f246e3">

># 플래시 메모리 유형
## 전기적으로 지울 수 있는 프로그래밍 가능 ROM(EEPROM)의 일종
## NOR 플래시: NOR 게이트와 같은 비트 셀
- 무작위 읽기/쓰기 액세스
- 임베디드 시스템의 명령어 메모리에 사용된다.
## NAND 플래시: NAND 게이트와 같은 비트 셀
- 밀도(비트/영역)는 높지만 한 번에 블록 액세스 가능
- GB당 가격이 저렴함
- USB 키, 미디어 저장 등에 사용된다
## 플래시 비트는 1000~100,000번의 액세스 후에 마모된다.
- 직접 RAM 또는 디스크 교체에 적합하지 않음
- 웨어 레벨링: 데이터를 덜 사용되는 블록으로 다시 매핑

># 디스크 저장소
## 비휘발성, 회전식 자기 스토리지
<img width="771" alt="스크린샷 2024-06-10 오후 3 24 52" src="https://github.com/junhyeok030213/computer-structure/assets/106813806/9e80469a-5e47-49c3-bdea-adb0a06cfedc">

># 디스크 섹터 및 액세스
## 각 부문별 기록
- 섹터 ID
- 데이터(512바이트, 4096바이트 제안)
- 오류 정정 코드(ECC)

  -> 결함을 숨기고 오류를 기록하는 데 사용된다.

- 동기화 필드 및 격차

## 특정 부문에 대한 접근에는 다음이 포함된다.
- 다른 액세스가 보류 중인 경우 대기열 지연
- 탐색: 머리를 움직인다.
- 회전 지연 시간

  -> 평균 지연 시간은 디스크의 절번 정도이다.(0.5회전에 소요되는 시간)

- 데이터 전송
- 컨트롤러 오버헤드

># 디스크 액세스 예
## Given
- 512 B 섹터, 15,000rpm, 4ms 평균 탐색 시간, 100MB/s 전송 속도, 0.2ms 컨트롤러 오버헤드, 유휴 디스크
## 평균 읽기 시간
- 4ms 탐색 시간 + 2ms(= (1/2) / (15,000/60)) 회전 대기 시간 + 0.005ms(= 512 B / 100MB/s) 전송 시간 + 0.2ms 컨트롤러 지연 = 6.2ms
## 실제 평균 탐색 시간이 1ms 라면,
- 평균 읽기 시간 = 3.2ms

># 디스크 성능 문제
## 제조업체는 평균 탐색 시간을 인용한다.
- 가능한 모든 탐색을 기반으로 함
- 지역성과 OS 스케줄링으로 인해 실제 평균 탐색 시간이 더 짧아진다.
## 스마트 디스크 컨트롤러
- SCSI(소형 컴퓨터 시스템 인터페이스), ATA(첨단 기술 부착), SATA(직렬 ATA)
## 디스크 드라이브에는 캐시가 포함되어 있다.
- 액세스가 예상되는 프리패치 섹터
- 탐색 및 회전 지연 방지

># 캐시 메모리
## 캐시 메모리
- CPU에 가장 가까운 메모리 계층 구조 수준
<img width="745" alt="스크린샷 2024-06-10 오후 3 42 17" src="https://github.com/junhyeok030213/computer-structure/assets/106813806/81341b0a-cab3-4e4e-851b-75741ff80c34">

># 직접 매핑된 캐시
## 주소로 결정되는 위치
## 직접 매핑: 단 하나의 선택
- (블록 주소) 모듈로 (캐시 내 #Blocks)

<img width="465" alt="스크린샷 2024-06-10 오후 3 45 08" src="https://github.com/junhyeok030213/computer-structure/assets/106813806/8e524267-72da-4fd2-b738-8c30292a415f">

># 태그 및 유효한 비트
## 캐시 위치에 어떤 특정 블록이 저장되어 있는지 어떻게 알 수 있나?
- 블록 주소와 데이터를 저장한다.
- 실제로는 상위 비트만 필요하다.
- 태그를 호출했다.
## 특정 위치에 데이터가 없으면 어떻게 되는가?
- 유효한 비트: 1 = 존재, 0 = 존재하지 않음
- 처음에는 0

># 캐시 예
## 8블록, 1워드/블록, 직접 매핑
## 초기 상태
<img width="492" alt="스크린샷 2024-06-10 오후 3 47 36" src="https://github.com/junhyeok030213/computer-structure/assets/106813806/63ee2364-3814-45c4-b640-6111a5011b29">

<img width="428" alt="스크린샷 2024-06-10 오후 3 48 09" src="https://github.com/junhyeok030213/computer-structure/assets/106813806/af14ed08-355e-4de5-b1f4-505b4389b5a2">

<img width="424" alt="스크린샷 2024-06-10 오후 3 48 23" src="https://github.com/junhyeok030213/computer-structure/assets/106813806/40303546-018d-4ba4-b35a-7ad8cd64ff1a">

<img width="425" alt="스크린샷 2024-06-10 오후 3 48 35" src="https://github.com/junhyeok030213/computer-structure/assets/106813806/9582d304-758d-4cac-a4b4-7f96e88a3c4e">

<img width="422" alt="스크린샷 2024-06-10 오후 3 48 48" src="https://github.com/junhyeok030213/computer-structure/assets/106813806/21e77d61-0b87-4cc8-848e-5c5d6a6b3455">

<img width="427" alt="스크린샷 2024-06-10 오후 3 49 04" src="https://github.com/junhyeok030213/computer-structure/assets/106813806/1913e99f-ef88-4396-a3e1-7635a5850586">

># 주소 세분화
<img width="368" alt="스크린샷 2024-06-10 오후 3 49 54" src="https://github.com/junhyeok030213/computer-structure/assets/106813806/f57b190e-18ec-463e-9d2f-859ba7e841d5">

># 예: 더 큰 블록 크기
## 64개 블록, 16바이트/불록
- 주소 1200은 어떤 블록 번호에 매핑되는가?
## 블록 주소 - ⎣주소/블록크기⎦ = ⎣1200/16⎦ = 75
## 블록 번호 = (블록 주소) modulo (#블록) = 75 modulo 64 = 11
<img width="379" alt="스크린샷 2024-06-10 오후 3 56 51" src="https://github.com/junhyeok030213/computer-structure/assets/106813806/1fe30ef6-4d6f-4cd0-9a97-fdb8231864d7">

># 블록 크기 고려 사항
## 블록이 클수록 미스 비율이 줄어든다.
- 공간적 지역성으로 이냏
## 하지만 고정된 크기의 캐시에서는
- 더 큰 블록 => 더 적은 수

  -> 경쟁 심화 => 미스율 증가

- 더 큰 블록 => 오염

## 미스 페널티가 커짐
- 감소된 미스 비율의 이점을 무시할 수 있다.
- 중요한 단어 우선 및 조기 재시작이 도움을 될 수 있다.

