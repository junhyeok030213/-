># **컴퓨터 혁명**
## 컴퓨터 기술의 진보
- 도메인별 가속기를 통해 지원

## 새로운 애플리케이션 실현
- 자동차의 컴퓨터
- 휴대전화
- 인간 게놈 프로젝트(인간 유전체 프로젝트)
- 월드 와이드 웹
- 검색 엔진

## 컴퓨터들은 퍼져있다!!!


># 컴퓨터 클래스
## 개인용 컴퓨터
- 개인적인 목적, 다양한 소프트웨어
- 가성비 거래 대상

## 서버 컴퓨터
- 네트워크 기반
- 높은 용량, 성능, 신뢰성
- 소규모 서버에서 건물 크기에 이르기까지 다양함

## 슈퍼 컴퓨터
- 서버 종류
- 고급 과학 및 공학 계산
- 최고의 기능을 제공하지만 전체 컴퓨터 시장의 적은 비율을 차지함

## 내장형 컴퓨터
- 시스템의 구성 요소로 숨김
- 전력소모량/성능/비용/제약사항에 엄격함
<img width="234" alt="스크린샷 2024-04-08 오후 7 34 05" src="https://github.com/junhyeok030213/-/assets/106813806/431d4676-aa6b-40db-bab5-5d51dbcdb14b">

># PC 다음 시대
<img width="642" alt="스크린샷 2024-04-08 오후 7 34 59" src="https://github.com/junhyeok030213/-/assets/106813806/31fd8cb3-9acf-4f57-b473-b33a312b5354">

## Personal mobile device (PMD) - 개인용 모바일 장치
- 배터리 작동
- 인터넷 연결
- 수백 달러
- 스마트폰, 태블릿, 전자 안경

## 클라우드 컴퓨팅
- Warehouse scale computers (WSC) - 창고 규모 시스템
>- 50,000대의 서버를 포함함
- Software as a Service (SaaS) - 서비스형 소프트웨어
- 소프트웨어의 일부는 PMD에서 실행되고 일부는 클라우드에서 실행됨
- 아마존, 구글

># 학습할 내용

## 프로그램이 기계어로 번역되는 방법
- 그리고 하드웨어가 그것들을 실행하는 방법

># 성능 이해
##  알고리즘
- 실행되는 작업 수를 결정함
## 프로그래밍 언어, 컴파일러, 아키텍처
- 작업당 실행되는 기계 명령 수 결정 **(컴파일러는 하드웨어를 속속히 알아야 만들수 있음)**
## 프로세서 및 메모리 시스템
- 명령어가 얼마나 빨리 실행되는지 확인함
## I/O 시스템(OS 포함)
- I/O 작업의 실행 속도를 결정함

># Seven Great Ideas
## 추상화를 사용하여 디자인 단순화
## 공통 케이스를 빠르게 만들기
## 병렬화를 통한 성능
## 파이프라이닝을 통한 성능
- 파이프라이닝이란 명령어의 데이터 경로를 세분화하고, 각기 다른 세부 단계를 동시에 수행하게 함으로써, 여러 명령어들을 중첩 수행 가능하게 만들어 성능을 향상하는 것을 의미
## 예측을 통한 성능
## 메모리들의 계층화
## 중복을 통한 신뢰성

># 프로그램의 아래
## 응용 소프트웨어
- 고급 언어로 작성됨
## 시스템 소프트웨어
<img width="210" alt="스크린샷 2024-04-08 오후 8 05 08" src="https://github.com/junhyeok030213/-/assets/106813806/7af798e9-50dd-4ce2-9785-237fe06a25da">

- 컴파일러: HLL 코드를 컴퓨터 코드로 변환함
- 운영 체제: 서비스 코드
>- 입출력처리
>- 메모리 및 스토리지 관리
>- 작업 스케줄링 및 리소스 공유

## 하드웨어
- 프로세서, 메모리, I/O 컨트롤러

># 프로그램 코드 레벨

<img width="596" alt="스크린샷 2024-04-11 오후 12 47 16" src="https://github.com/junhyeok030213/-/assets/106813806/db4f2903-db10-4208-a055-957e15432eff">


## 고급 언어
- 문제 영역에 가까운 추상화 수준
- 생산성과 휴대성 제공
## 어셈블리어
- 명령어의 텍스트 표현
## 하드웨어 표현
- 이진수(비트)
- 인코딩된 명령어 및 데이터

># 컴퓨터의 구성 요소
## 모든 종류의 컴퓨터에 동일한 구성 요소
- 데스크탑, 서버, 임베디드 컴퓨터
## 입력/출력에는 다음이 포함됨
- 사용자 인터페이스 장치
>- 디스플레이, 키보드, 마우스
- 저장 장치
>- 하드디스크, CD/DVD, 플래시
- 네트워크 어댑터
>- 다른 컴퓨터와 통신하기 위해

># 터치 스크린
## 포스트 PC 장치
## 키보드와 마우스 대체
## 저항성 및 용량성 유형
- 대부분의 태블릿과 스마트폰은 정전식을 사용
- 정전식 방식으로 동시에 여러 터치가 가능

># 보이는 유리를 통하여

<img width="764" alt="스크린샷 2024-04-11 오후 12 52 36" src="https://github.com/junhyeok030213/-/assets/106813806/31b468ba-221f-4cec-bc7b-cda4af6fc24c">

## LCD화면: 픽셀(화소) 요소
- 화면에 표현될 이미지는 프레임 버퍼에 저장된다.

># 

<img width="973" alt="스크린샷 2024-04-11 오후 12 56 56" src="https://github.com/junhyeok030213/-/assets/106813806/e6b593fa-7eea-4a0a-929c-a4ba32b25f29">

># 프로세서(CPU) 내부
## 데이터 경로
- 데이터에 대한 작업을 수행한다
## 제어
- 시퀸스 데이터 경로, 메모리, ...
## 캐시(cache) 메모리
- 데이터에 즉시 액세스할 수 있는 작고 빠른 SRAM 메모리
>- RAM: Random Acess Memory (임의접근)
>- SRAM: 빠름       DRAM: Dynamic(동적) RAM

># Abstractions (추상화?)
**큰그림**

## 추상화는 복잡성을 처리하는 데 도움이 된다.
- 하위 수준의 세부정보 숨기기
## ISA(Instruction Set Architecture) - 명령 집합 아키텍처
- 하드웨어/소프트웨어 인터페이스
## 애플리케이션 바이너리 인터페이스
- ISA plus 시스템 소프트웨어 인터페이스
## Implementation - 구현
- 기본 및 인터페이스 세부정보

># 데이터를 위한 안전한 장소

<img width="460" alt="스크린샷 2024-04-11 오후 1 09 58" src="https://github.com/junhyeok030213/-/assets/106813806/1969450d-fc1d-4f27-a1fc-a792aeb91399">


## 휘발성 주 기억장치
- 전원이 꺼지면 지침과 데이터가 손실된다.
## 비휘발성 보조 메모리
- 자기(Magnetic) 디스크
- 플래시 메모리
- 광디스크(CD, DVD)

<img width="521" alt="스크린샷 2024-04-11 오후 1 11 01" src="https://github.com/junhyeok030213/-/assets/106813806/d15105c4-27ca-4560-bf1f-e771cf78725b">

># 네트워크
## 커뮤니케이션 및 자원 공유
## LAN(근거리 통신망): 이더넷 - 유선
## WAN(광역 네트워크): 인터넷 - 유선
## 무선 네트워크: WIFI, 블루투스 - 무선
## AP - Acess Point

># 기술동향
## 전자기술은 계속 발전하고 있다.
- 용량 및 성능 향상
- 비용 절감

<img width="802" alt="스크린샷 2024-04-11 오후 1 17 37" src="https://github.com/junhyeok030213/-/assets/106813806/17033017-c8ef-469b-bcd5-7110e088ae3f">

## 시간 경과에 따른 DRAM 용량 증가
- DRAM: 동적 랜덤 액세스 메모리

<img width="908" alt="스크린샷 2024-04-11 오후 1 19 29" src="https://github.com/junhyeok030213/-/assets/106813806/ef68051b-42fc-4468-9645-ecc078efa9ed">

># 제조 IC
## 수율: 웨이퍼당 작업 다이의 비율

<img width="818" alt="스크린샷 2024-04-11 오후 1 22 09" src="https://github.com/junhyeok030213/-/assets/106813806/7a32f26f-0620-4948-bce9-48c27e584895">

># 인텔 코어 10세대

<img width="654" alt="스크린샷 2024-04-11 오후 1 23 49" src="https://github.com/junhyeok030213/-/assets/106813806/a7cafc49-019a-476f-a629-9d472439af3d">


## 300mm 웨이퍼, 506개 칩, 10nm 기술
## 각 칩의 크기는 11.4 x 10.7mm 이다.

># 집적 회로 비용
<img width="686" alt="스크린샷 2024-04-11 오후 1 25 57" src="https://github.com/junhyeok030213/-/assets/106813806/5159990a-3d89-4506-a1ad-e2430cc5b7f2">

## 면적 및 결함률과의 비선형 관계
- 웨이퍼 비용과 면적은 고정되어 있음.
- 불량률은 제조공정에 따라 결정됨.
- 다이 면적은 아키텍처와 회로 설계에 따라 결정됨.

># 성능 정의
## 어떤 비행기가 최고의 성능을 발휘하나?
<img width="827" alt="스크린샷 2024-04-11 오후 1 28 06" src="https://github.com/junhyeok030213/-/assets/106813806/8c5794b9-4087-4816-9e10-274fe5ff61ea">

># 응답 시간 및 처리량
## 응답 시간
- 작업을 수행하는데 얼마나 걸리나
## 처리량
- 단위시간당 수행된 총 작업량
- ex) 작업/트랜잭션/... 시간당
## 응답 시간과 처리량은 어떤 영향을 받나?
- 프로세서를 더 빠른 버전으로 교체

-> 응답시간(작업 실행 시간) 단축
  
- 프로세서를 더 추가

-> 처리량 증가(처리된 작업 수)
  
## 지금은 응답 시간에 집중

># 상대적 성능
## 성능 정의 = 1/실행시간
## "X는 Y보다 n배 빠릅니다."

<img width="567" alt="스크린샷 2024-04-11 오후 1 40 20" src="https://github.com/junhyeok030213/-/assets/106813806/52703b86-547d-4e7a-bfc1-e472f6f75636">
<img width="290" alt="스크린샷 2024-04-11 오후 1 36 02" src="https://github.com/junhyeok030213/-/assets/106813806/09fe15dd-de40-4192-b87f-05a7cef090c2">

## 예(p.31): 프로그램을 실행하는 데 걸린 시간
<img width="787" alt="스크린샷 2024-04-11 오후 1 38 47" src="https://github.com/junhyeok030213/-/assets/106813806/ad51f3f9-0719-4e1b-83b4-c90a5f571ee1">

># 실행 시간 측정
## 경과 시간 (모든 시간 +)
- 모든 측면을 포함한 총 응답 시간

-> CPU처리시간, OS 오버헤드, 아무것도 안하는 시간

- 시스템 성능 결정
## CPU time - 순수에게 CPU에서만
- 특정 작업을 처리하는데 소요된 시간

-> I/O 시간, 다른 작업 할당량 할인

- 사용자 CPU 시간과 시스템 CPU 시간으로 구성됨
- 다양한 프로그램은 CPU 및 시스템 성능에 따라 다르게 영향을 받음

># CPU 클로킹
## 일정한 속도의 클럭으로 제어되는 디지털 하드웨어의 작동
