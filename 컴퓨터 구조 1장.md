># **컴퓨터 혁명**
## 컴퓨터 기술의 진보
- 도메인별 가속기를 통해 지원

## 새로운 애플리케이션 실현
- 자동차의 컴퓨터
- 휴대전화
- 인간 게놈 프로젝트(인간 유전체 프로젝트)
- 월드 와이드 웹
- 검색 엔진

## 컴퓨터들은 퍼져있다!!!


># 컴퓨터 클래스
## 개인용 컴퓨터
- 개인적인 목적, 다양한 소프트웨어
- 가성비 거래 대상

## 서버 컴퓨터
- 네트워크 기반
- 높은 용량, 성능, 신뢰성
- 소규모 서버에서 건물 크기에 이르기까지 다양함

## 슈퍼 컴퓨터
- 서버 종류
- 고급 과학 및 공학 계산
- 최고의 기능을 제공하지만 전체 컴퓨터 시장의 적은 비율을 차지함

## 내장형 컴퓨터
- 시스템의 구성 요소로 숨김
- 전력소모량/성능/비용/제약사항에 엄격함
<img width="234" alt="스크린샷 2024-04-08 오후 7 34 05" src="https://github.com/junhyeok030213/-/assets/106813806/431d4676-aa6b-40db-bab5-5d51dbcdb14b">

># PC 다음 시대
<img width="642" alt="스크린샷 2024-04-08 오후 7 34 59" src="https://github.com/junhyeok030213/-/assets/106813806/31fd8cb3-9acf-4f57-b473-b33a312b5354">

## Personal mobile device (PMD) - 개인용 모바일 장치
- 배터리 작동
- 인터넷 연결
- 수백 달러
- 스마트폰, 태블릿, 전자 안경

## 클라우드 컴퓨팅
- Warehouse scale computers (WSC) - 창고 규모 시스템
>- 50,000대의 서버를 포함함
- Software as a Service (SaaS) - 서비스형 소프트웨어
- 소프트웨어의 일부는 PMD에서 실행되고 일부는 클라우드에서 실행됨
- 아마존, 구글

># 학습할 내용

## 프로그램이 기계어로 번역되는 방법
- 그리고 하드웨어가 그것들을 실행하는 방법

># 성능 이해
##  알고리즘
- 실행되는 작업 수를 결정함
## 프로그래밍 언어, 컴파일러, 아키텍처
- 작업당 실행되는 기계 명령 수 결정 **(컴파일러는 하드웨어를 속속히 알아야 만들수 있음)**
## 프로세서 및 메모리 시스템
- 명령어가 얼마나 빨리 실행되는지 확인함
## I/O 시스템(OS 포함)
- I/O 작업의 실행 속도를 결정함

># Seven Great Ideas
## 추상화를 사용하여 디자인 단순화
## 공통 케이스를 빠르게 만들기
## 병렬화를 통한 성능
## 파이프라이닝을 통한 성능
- 파이프라이닝이란 명령어의 데이터 경로를 세분화하고, 각기 다른 세부 단계를 동시에 수행하게 함으로써, 여러 명령어들을 중첩 수행 가능하게 만들어 성능을 향상하는 것을 의미
## 예측을 통한 성능
## 메모리들의 계층화
## 중복을 통한 신뢰성

># 프로그램의 아래
## 응용 소프트웨어
- 고급 언어로 작성됨
## 시스템 소프트웨어
<img width="210" alt="스크린샷 2024-04-08 오후 8 05 08" src="https://github.com/junhyeok030213/-/assets/106813806/7af798e9-50dd-4ce2-9785-237fe06a25da">

- 컴파일러: HLL 코드를 컴퓨터 코드로 변환함
- 운영 체제: 서비스 코드
>- 입출력처리
>- 메모리 및 스토리지 관리
>- 작업 스케줄링 및 리소스 공유

## 하드웨어
- 프로세서, 메모리, I/O 컨트롤러

># 프로그램 코드 레벨

<img width="596" alt="스크린샷 2024-04-11 오후 12 47 16" src="https://github.com/junhyeok030213/-/assets/106813806/db4f2903-db10-4208-a055-957e15432eff">


## 고급 언어
- 문제 영역에 가까운 추상화 수준
- 생산성과 휴대성 제공
## 어셈블리어
- 명령어의 텍스트 표현
## 하드웨어 표현
- 이진수(비트)
- 인코딩된 명령어 및 데이터

># 컴퓨터의 구성 요소
## 모든 종류의 컴퓨터에 동일한 구성 요소
- 데스크탑, 서버, 임베디드 컴퓨터
## 입력/출력에는 다음이 포함됨
- 사용자 인터페이스 장치
>- 디스플레이, 키보드, 마우스
- 저장 장치
>- 하드디스크, CD/DVD, 플래시
- 네트워크 어댑터
>- 다른 컴퓨터와 통신하기 위해

># 터치 스크린
## 포스트 PC 장치
## 키보드와 마우스 대체
## 저항성 및 용량성 유형
- 대부분의 태블릿과 스마트폰은 정전식을 사용
- 정전식 방식으로 동시에 여러 터치가 가능

># 보이는 유리를 통하여

<img width="764" alt="스크린샷 2024-04-11 오후 12 52 36" src="https://github.com/junhyeok030213/-/assets/106813806/31b468ba-221f-4cec-bc7b-cda4af6fc24c">

## LCD화면: 픽셀(화소) 요소
- 화면에 표현될 이미지는 프레임 버퍼에 저장된다.

># 

<img width="973" alt="스크린샷 2024-04-11 오후 12 56 56" src="https://github.com/junhyeok030213/-/assets/106813806/e6b593fa-7eea-4a0a-929c-a4ba32b25f29">

># 프로세서(CPU) 내부
## 데이터 경로
- 데이터에 대한 작업을 수행한다
## 제어
- 시퀸스 데이터 경로, 메모리, ...
## 캐시(cache) 메모리
- 데이터에 즉시 액세스할 수 있는 작고 빠른 SRAM 메모리
>- RAM: Random Acess Memory (임의접근)
>- SRAM: 빠름       DRAM: Dynamic(동적) RAM

># Abstractions (추상화?)
**큰그림**

## 추상화는 복잡성을 처리하는 데 도움이 된다.
- 하위 수준의 세부정보 숨기기
## ISA(Instruction Set Architecture) - 명령 집합 아키텍처
- 하드웨어/소프트웨어 인터페이스
## 애플리케이션 바이너리 인터페이스
- ISA plus 시스템 소프트웨어 인터페이스
## Implementation - 구현
- 기본 및 인터페이스 세부정보

># 데이터를 위한 안전한 장소

<img width="460" alt="스크린샷 2024-04-11 오후 1 09 58" src="https://github.com/junhyeok030213/-/assets/106813806/1969450d-fc1d-4f27-a1fc-a792aeb91399">


## 휘발성 주 기억장치
- 전원이 꺼지면 지침과 데이터가 손실된다.
## 비휘발성 보조 메모리
- 자기(Magnetic) 디스크
- 플래시 메모리
- 광디스크(CD, DVD)

<img width="521" alt="스크린샷 2024-04-11 오후 1 11 01" src="https://github.com/junhyeok030213/-/assets/106813806/d15105c4-27ca-4560-bf1f-e771cf78725b">

># 네트워크
## 커뮤니케이션 및 자원 공유
## LAN(근거리 통신망): 이더넷 - 유선
## WAN(광역 네트워크): 인터넷 - 유선
## 무선 네트워크: WIFI, 블루투스 - 무선
## AP - Acess Point

># 기술동향
## 전자기술은 계속 발전하고 있다.
- 용량 및 성능 향상
- 비용 절감

<img width="802" alt="스크린샷 2024-04-11 오후 1 17 37" src="https://github.com/junhyeok030213/-/assets/106813806/17033017-c8ef-469b-bcd5-7110e088ae3f">

## 시간 경과에 따른 DRAM 용량 증가
- DRAM: 동적 랜덤 액세스 메모리

<img width="908" alt="스크린샷 2024-04-11 오후 1 19 29" src="https://github.com/junhyeok030213/-/assets/106813806/ef68051b-42fc-4468-9645-ecc078efa9ed">

># 제조 IC
## 수율: 웨이퍼당 작업 다이의 비율

<img width="818" alt="스크린샷 2024-04-11 오후 1 22 09" src="https://github.com/junhyeok030213/-/assets/106813806/7a32f26f-0620-4948-bce9-48c27e584895">

># 인텔 코어 10세대

<img width="654" alt="스크린샷 2024-04-11 오후 1 23 49" src="https://github.com/junhyeok030213/-/assets/106813806/a7cafc49-019a-476f-a629-9d472439af3d">


## 300mm 웨이퍼, 506개 칩, 10nm 기술
## 각 칩의 크기는 11.4 x 10.7mm 이다.

># 집적 회로 비용
<img width="686" alt="스크린샷 2024-04-11 오후 1 25 57" src="https://github.com/junhyeok030213/-/assets/106813806/5159990a-3d89-4506-a1ad-e2430cc5b7f2">

## 면적 및 결함률과의 비선형 관계
- 웨이퍼 비용과 면적은 고정되어 있음.
- 불량률은 제조공정에 따라 결정됨.
- 다이 면적은 아키텍처와 회로 설계에 따라 결정됨.

># 성능 정의
## 어떤 비행기가 최고의 성능을 발휘하나?
<img width="827" alt="스크린샷 2024-04-11 오후 1 28 06" src="https://github.com/junhyeok030213/-/assets/106813806/8c5794b9-4087-4816-9e10-274fe5ff61ea">

># 응답 시간 및 처리량
## 응답 시간
- 작업을 수행하는데 얼마나 걸리나
## 처리량
- 단위시간당 수행된 총 작업량
- ex) 작업/트랜잭션/... 시간당
## 응답 시간과 처리량은 어떤 영향을 받나?
- 프로세서를 더 빠른 버전으로 교체

  -> 응답시간(작업 실행 시간) 단축
  
- 프로세서를 더 추가

  -> 처리량 증가(처리된 작업 수)
  
## 지금은 응답 시간에 집중

># 상대적 성능
## 성능 정의 = 1/실행시간
## "X는 Y보다 n배 빠릅니다."

<img width="567" alt="스크린샷 2024-04-11 오후 1 40 20" src="https://github.com/junhyeok030213/-/assets/106813806/52703b86-547d-4e7a-bfc1-e472f6f75636">
<img width="290" alt="스크린샷 2024-04-11 오후 1 36 02" src="https://github.com/junhyeok030213/-/assets/106813806/09fe15dd-de40-4192-b87f-05a7cef090c2">

## 예(p.31): 프로그램을 실행하는 데 걸린 시간
<img width="787" alt="스크린샷 2024-04-11 오후 1 38 47" src="https://github.com/junhyeok030213/-/assets/106813806/ad51f3f9-0719-4e1b-83b4-c90a5f571ee1">

># 실행 시간 측정
## 경과 시간 (모든 시간 +)
- 모든 측면을 포함한 총 응답 시간

  -> CPU처리시간, OS 오버헤드, 아무것도 안하는 시간

- 시스템 성능 결정
## CPU time - 순수에게 CPU에서만
- 특정 작업을 처리하는데 소요된 시간

  -> I/O 시간, 다른 작업 할당량 할인

- 사용자 CPU 시간과 시스템 CPU 시간으로 구성됨
- 다양한 프로그램은 CPU 및 시스템 성능에 따라 다르게 영향을 받음

># CPU 클로킹
## 일정한 속도의 클럭으로 제어되는 디지털 하드웨어의 작동
<img width="837" alt="스크린샷 2024-04-11 오후 2 02 05" src="https://github.com/junhyeok030213/-/assets/106813806/e5f50e93-6f6b-41f3-b9c6-36e029d8a1b6">

## 클럭 주기: 클럭 주기의 지속 시간
- 예: <img width="351" alt="스크린샷 2024-04-11 오후 2 04 06" src="https://github.com/junhyeok030213/-/assets/106813806/e9482644-c015-4ebb-8403-bf71ae82dc94">
## 클럭 주파수(속도): 초당 사이클
- 예: <img width="382" alt="스크린샷 2024-04-11 오후 2 04 30" src="https://github.com/junhyeok030213/-/assets/106813806/a6a5a540-e97a-490b-b2bc-aa4bfe8218a4">

<img width="613" alt="스크린샷 2024-04-11 오후 2 07 54" src="https://github.com/junhyeok030213/-/assets/106813806/5347d72d-d991-4ab7-ae52-51d35507e702">
<img width="249" alt="스크린샷 2024-04-11 오후 2 08 55" src="https://github.com/junhyeok030213/-/assets/106813806/bbac8970-87d4-44d0-8a06-a145697934a1">

># CPU 시간
<img width="736" alt="스크린샷 2024-04-11 오후 2 10 02" src="https://github.com/junhyeok030213/-/assets/106813806/4858717b-652d-45d7-8ad0-70656f58aee1">

## 성능 향상
- 클럭 사이클 수 감소
- 클럭 속도 증가
- 하드웨어 설계자는 종종 사이클 수와 클럭 속도를 절충해야 한다.

># CPU 시간 예) p.34
## 컴퓨터 A: 2GHz 클럭, 10초 CPU 시간
## 설계 컴퓨터 B
- 6초 CPU 시간을 목표로 한다
- 더 빠른 클럭을 수행할 수 있지만 1.2배의 클럭 주기가 발생한다.
## 컴퓨터 B의 클럭은 얼마나 빨라야 하나?
<img width="771" alt="스크린샷 2024-04-11 오후 2 16 11" src="https://github.com/junhyeok030213/-/assets/106813806/41077ccb-7be9-49c3-b48f-b04321dd285d">

># 명령어 수 및 CPI
<img width="818" alt="스크린샷 2024-04-11 오후 2 17 29" src="https://github.com/junhyeok030213/-/assets/106813806/69b9504c-9e1d-4c7c-a539-1d5be843f85a">

## 프로그램 명령어 수
- 프로그램, ISA 및 컴파일러에 의해 결정됨
## 명령어당 평균 사이클(CPI)
- CPU 하드웨어에 따라 결정됨
- 서로 다른 명령어에 서로 다른 CPI가 있는 경우 평균 CPI는 명령어 조합의 영향을 받는다.

># CPI 예) p.36
## 컴퓨터 A: 사이클 시간 = 250ps(= 1/4ns), CPI = 2.0
## 컴퓨터 B: 사이클 시간 = 500ps(= 3/2ns), CPI = 1.2
## 같은 ISA
## 어느것이 빠르고 얼마나 더 빠른가?
<img width="765" alt="스크린샷 2024-04-11 오후 2 22 30" src="https://github.com/junhyeok030213/-/assets/106813806/c54eba4b-9305-4517-8739-c759a69e0e78">

># CPI 자세히 알아보기
## 서로 다른 명령어 클래스가 서로 다른 주기 수를 사용하는 경우
<img width="590" alt="스크린샷 2024-04-11 오후 5 08 07" src="https://github.com/junhyeok030213/-/assets/106813806/4814d69d-04bd-4b1d-82e3-b45fda4d5d3f">

## 가중 평균 CPI
<img width="760" alt="스크린샷 2024-04-11 오후 5 08 37" src="https://github.com/junhyeok030213/-/assets/106813806/c679b945-083e-4627-bc68-2da7804547cc">

># CPI 예) p.37

## 클래스 A,B,C의 명령어를 사용하는 대체 컴파일된 코드 시퀀스
<img width="668" alt="스크린샷 2024-04-11 오후 5 10 19" src="https://github.com/junhyeok030213/-/assets/106813806/b49df97f-2dc7-4a94-aec3-bcfbcab4cb1c">

## 시퀀스 1: IC=5
- 클럭 사이클 = 2x1 + 1x2 + 2x3 = 10
## 시퀀스 2: IC=6
- 클럭 사이클 = 4x1 + 1x2 + 1x3 = 9

># 성능 요약
<img width="805" alt="스크린샷 2024-04-11 오후 5 16 31" src="https://github.com/junhyeok030213/-/assets/106813806/198a96cb-7767-47cc-b2e3-2a93350f5a86">

## 성능은 다음에 따라 달라진다.
- 알고리즘: IC에 영향을 미치며, CPI에도 영향을 미칠 수 있다.
- 프로그래밍 언어: IC, CPPI에 영향을 미친다.
- 컴파일러: IC, CPI에 영향을 미친다.
- 명령어ㅓ 세트 아키텍쳐: IC, CPI, T(사이클 시간)에 영향을 미친다.

># 전력 동향
<img width="860" alt="스크린샷 2024-04-11 오후 5 17 44" src="https://github.com/junhyeok030213/-/assets/106813806/48a65f30-e729-496b-aca0-b412ea2e34e3">

## CMOS IC (금속 산화 반도체) 기술에서는,

<img width="743" alt="스크린샷 2024-04-11 오후 5 19 20" src="https://github.com/junhyeok030213/-/assets/106813806/50e30512-f60a-4295-825d-ded1bb130e89">

># 전력 감소

## 새로운 CPU가 있다고 가정하자
- 기존 CPU 용량 부하의 85%
- 전압 15%, 주파수 15% 감소
<img width="740" alt="스크린샷 2024-04-11 오후 5 20 51" src="https://github.com/junhyeok030213/-/assets/106813806/4565d169-ca9c-4a46-a5b3-c0727dd8fc3e">

## The power wall (파워 월)
- 더 이상 전압을 낮출 수 없습니다
- 더 이상 열을 제거할 수 없습니다
## 성능을 향상시킬 수 있는 또 다른 방법은 무엇일까?
<img width="626" alt="스크린샷 2024-04-11 오후 5 23 12" src="https://github.com/junhyeok030213/-/assets/106813806/2be67919-c064-41d4-bb33-b90a2cb33e01">

># 멀티 프로세서
## 멀티코어 마이크로프로세서
- 칩당 프로세서 2개 이상(여러개)
- 병렬처리, 병행처리 가능
## 명시적인 병렬 프로그래밍 필요
- 명령 수준 병렬과 비교

  -> 하드웨어는 여러 명령을 동시에 실행한다.

  -> 프로그래머에게 숨겨짐

- 하기 어렵다

  -> 성능 고려

  -> CPU 간의 부합가능

  -> 통신 및 동기화 최적화

># SPEC CPU 벤치마크
## 성능 측정에 사용되는 프로그램
- 실제 워크로드의 일반적인 것으로 추정됨
## Standard Performance Evaluation Corporation (SPEC) - 표준성능평가법인
- CPU, I/O , 웹 등에 대한 벤치마크 개발...
- http://www.spec.org// (1989년 설립)
## SPEC CPU2017
- 선택한 프로그램을 실행하는데 소요된 시간

-> I/O가 무시되므로 CPU 성능에 중점을 둔다.

- 참조 시스템을 기준으로 정규화
- 성능비의 기하평균으로 요약

-> SPECspeed2017 Integer (10개의 정수 벤치마크)

-> SPECspeed2017 Floating Point (13개 부동 소수점 벤치마크)

<img width="296" alt="스크린샷 2024-04-11 오후 5 40 21" src="https://github.com/junhyeok030213/-/assets/106813806/b1e827b3-1267-4b33-8446-e55ee86eb2a2">
<img width="252" alt="스크린샷 2024-04-11 오후 5 40 03" src="https://github.com/junhyeok030213/-/assets/106813806/ec4ca79b-7ba9-4b5e-85b3-1bcc0e3c7f51">

># SPECspeed 2017 정수 벤치마크 (1.8GHz Intel Xeon E5-2650L에서 실행)
<img width="649" alt="스크린샷 2024-04-11 오후 5 42 29" src="https://github.com/junhyeok030213/-/assets/106813806/60d31bb0-b510-4f4d-8aa8-89728453289d">

># SPEC 전력 벤치마크
## 다양한 워크로드 수준에서 서버의 전력 소비
- 성능: ssj_ops/sec
- 전력: Watts (Joules/sec)

<img width="708" alt="스크린샷 2024-04-11 오후 5 48 51" src="https://github.com/junhyeok030213/-/assets/106813806/a75e861c-d09b-4a0f-b3b3-413c979b42fa">


## SPECpower_ssj2008은 기본적으로 ssj_ops/Watt의 척도이다.
## server side Java operations per second per watt (와트당 초당 서버츨 JAVA 작업)
- ssj_ops/Watt는 서버 측 자바 연산을 줄 단위로 하는 것입니다. 왜냐하면 "초당 와트"는 정의상 "줄 단위"이기 때문입니다.

># SPECpower_ssj2008 벤치마크 (2.2GHz Xeon Platinum 8276L에서 실행)
<img width="473" alt="스크린샷 2024-04-11 오후 5 50 40" src="https://github.com/junhyeok030213/-/assets/106813806/1413147b-494d-48ff-9161-1ec7ba004b07">

># 더 빠르게: 최적화(Python의 행렬 곱셈)
<img width="729" alt="스크린샷 2024-04-11 오후 5 51 39" src="https://github.com/junhyeok030213/-/assets/106813806/d3d92a3d-af91-4f2e-ad8d-37206e9bee01">

># Pitfall(함정): Amdahl's Law (암달의 법칙)
## 컴퓨터의 측면을 개선하고 전반적인 성능의 비례적인 향상을 기대한다.
<img width="548" alt="스크린샷 2024-04-11 오후 5 53 36" src="https://github.com/junhyeok030213/-/assets/106813806/6d345794-d639-4f9a-9651-4b496da60037">

예) 계정에 80을 곱합니다(총 100 이상)

<img width="937" alt="스크린샷 2024-04-11 오후 6 09 51" src="https://github.com/junhyeok030213/-/assets/106813806/17ffb6c9-1856-47ea-b190-083431335951">

># Fallacy(잘못된 생각): Low Power at Idle - 유휴시 저전력
##  i7 전력 벤치마크에서의 전력 소모
- 100% 부하 시: 258W
- 50% 부하 시: 170W(66%)
- 10% 부하 시: 121W(47$)

## 구글 데이터 센터
- 대부분 10% ~ 50% 부하에서 동작
- 100% 로드 시, 1% 미만의 시간

## 전력이 부하에 비례하도록 프로세서를 설계하는 것을 고려해야 한다.

># Pitfall(함정): 성능 지표로서의 MIPS
## MIPS: 초당 수백만 개의 명령
- 설명하지 않음

-> 컴퓨터 간 ISA의 차이점

-> 명령 간의 복잡성 차이

<img width="641" alt="스크린샷 2024-04-11 오후 6 16 37" src="https://github.com/junhyeok030213/-/assets/106813806/1df0abfb-1689-4a11-9458-7ca7d3119a7a">

- CPI는 특정 CPU의 프로그램마다 다르다.

># 마지막 정리

## 가성비가 향상되고 있다.
- 기반 기술 개발로 인해
## 추상화의 계층적 레이어
- 하드웨어와 소프트웨어 모두에서
## 명령어 세트 아키텍처
- 하드웨어/소프트웨어 인터페이스
## 실행 시간: 최고의 성능 측정
## 힘은 제한 요소이다
- 병렬성을 사용하여 성능 향상
