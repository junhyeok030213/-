># 소개
## CPU 성능 요소
- 명령어 수

  -> ISA 및 컴파일러에 의해 결정됨

- CPI 및 주기 시간

  -> CPU 하드에어에 따라 결정됨

## 두 가지 MIPS 구현을 살펴봄
- 단순화된 버전
- 보다 현실적인 파이프라인 버전

## 단순 하위 집합으로 대부분의 측면을 보여줌
- 메모리 참조: 1w, sw
- 산술/논리: add, sub, and, or, slt
- 제어 전송: beq, j

># 명령어 실행
## PC -> 명령 메모리: 명령 가져오기
## 레지스터 번호 -> 레지스터 파일: 레지스터 읽기
## 명령어 클래스에 따라
- ALU를 사용하여 계산

  -> 산술 결과

  -> 로드/저장을 위한 메모리 주소

  -> 지점 대상 주소

- 로드/저장을 위해 데이터 메모리에 액세스
- PC <- 대상 주소 또는 PC + 4

># CPU 개요
<img width="668" alt="스크린샷 2024-06-05 오후 4 48 14" src="https://github.com/junhyeok030213/computer-structure/assets/106813806/7f75e418-249c-4dac-9283-eeef23598ffb">

># 멀티플렉서
<img width="569" alt="스크린샷 2024-06-05 오후 4 50 18" src="https://github.com/junhyeok030213/computer-structure/assets/106813806/e6fa267d-3d9c-4c17-a8a6-c77654dd7d64">

## 전선을 함께 연결할 수 없다.
- 멀티플렉서를 사용하라

># 통제
<img width="507" alt="스크린샷 2024-06-05 오후 4 51 49" src="https://github.com/junhyeok030213/computer-structure/assets/106813806/882271f1-d77b-43d4-b8ca-5fb4aadb7f5a">

- 파란색 신호는 제어 신호입니다!

># 논리 설계 기초
## 이진수(0,1)로 인코딩된 정보
- 저전압 = 0 , 고전압 = 1
- 비트당 와이어 1개
- 다중 와이어 버스에 인코딩된 다중 비트 데이터
## 조합요소
- 데이터 작업
- 출력은 입력의 함수이다.
## 상태(순차) 요소
- 가게 정보

># 조합 요소
<img width="482" alt="스크린샷 2024-06-05 오후 5 14 05" src="https://github.com/junhyeok030213/computer-structure/assets/106813806/4d6c70a6-c15e-44d2-afb8-a22fae87037e">

># 순차적 요소
## 레지스터: 데이터를 회로에 저장
- 클럭 신호를 사용하여 저장된 값을 업데이트할 시기를 결정한다.
- Edge-triggered: Clk가 0에서 1로 변경될 때 업데이트된다.
<img width="577" alt="스크린샷 2024-06-05 오후 5 16 56" src="https://github.com/junhyeok030213/computer-structure/assets/106813806/1fe555ec-3336-4f49-8906-c710794f77a7">

## 쓰기 제어에 등록
- 쓰기 제어 입력이 1일 때 클록 에지 에서만 업데이트 된다.
- 나중에 저장된 값이 필요할 때 사용된다.
<img width="693" alt="스크린샷 2024-06-05 오후 5 19 59" src="https://github.com/junhyeok030213/computer-structure/assets/106813806/92748115-3211-429f-bc71-6327d96aef0b">

># 클로킹 방법론
## 조합 논리는 클록 주기 동안 데이터를 변환한다.
- 클록 에지 사이
- 상태 요소에서 입려그 상태 요소로 출력
- 가장 긴 지연이 클록 주기를 결정한다.
<img width="599" alt="스크린샷 2024-06-05 오후 5 24 50" src="https://github.com/junhyeok030213/computer-structure/assets/106813806/856cd53d-cffd-4a13-991b-346c1e83ef17">

># 데이터 경로 구축
## 데이터 경로
- CPU에서 데이터와 주소를 처리하는 요소

  -> 레지스터, ALU, mux, 메모리, ...

## MIPS 데이터 경로를 점진적으로 구축
- 개요 디자인 개선

># 명령어 가져오기
<img width="618" alt="스크린샷 2024-06-05 오후 5 28 57" src="https://github.com/junhyeok030213/computer-structure/assets/106813806/6c7060c2-1257-4ebb-b855-278474a16db8">

># R 형식 지침
## 두 개의 레지스터 피연산자 읽기
## 산술/논리 연산 수행
## 레지스터 결과 쓰기
<img width="507" alt="스크린샷 2024-06-05 오후 5 49 36" src="https://github.com/junhyeok030213/computer-structure/assets/106813806/94c6856a-7076-4a5d-8ac1-73f10ea28b3b">

># 로드/저장 지침
## 레지스터 피연산자 읽기
## 16비트 오프셋을 사용하여 주소 계산
- ALU를 사용하지만 부호 확장 오프셋
## 로드: 메모리 읽기 및 레지스터 업데이트
## Store: 레지스터 값을 메모리에 쓴다.
<img width="328" alt="스크린샷 2024-06-05 오후 5 51 10" src="https://github.com/junhyeok030213/computer-structure/assets/106813806/c709b55c-3161-4ffd-bf55-8e76ae971904">

># Branch Instructions
## 레지스터 피연산자 읽기
## 피연산자 비교
- ALU를 이용하여 Zero 출력을 빼고 확인한다.
## 대상 주소 계산
- 부호 확장 변위
- 왼쪽으로 2 Shift 이동(단어 치환)

  -> 쉬프트 2 = x4

- PC에 추가 + 4

  -> 명령어 가져오기로 이미 계산됨

<img width="579" alt="스크린샷 2024-06-05 오후 5 56 11" src="https://github.com/junhyeok030213/computer-structure/assets/106813806/06b290b2-85c3-4e62-8b1b-a1abbaebacfc">

># 요소 구성
## 첫 번째 컷 데이터 경로는 한 클럭 주기로 명령을 수행한다.
- 각 데이터 경로 요소는 한 번에 하나의 기능만 수행할 수 있다.
- 따라서 별도의 명령어와 데이터 메모리가 필요하다.
## 다른 명령에 대체 데이터 소스가 사용되는 멀티플렉서를 사용해라.

># R 유형/로드/저장 데이터 경로
<img width="550" alt="스크린샷 2024-06-05 오후 5 58 27" src="https://github.com/junhyeok030213/computer-structure/assets/106813806/d9124be6-cc20-406a-852c-3563f5a66feb">

># 전체 데이터 경로
<img width="500" alt="스크린샷 2024-06-05 오후 5 59 13" src="https://github.com/junhyeok030213/computer-structure/assets/106813806/71b53b16-e5cb-4fc0-b8c0-3cb37c835c22">

># ALU 제어
## ALU는 다음 용도로 사용된다.
- 로드/저장: F = add (F: Function)
- Branch: F = subtract
- R-type: F는 함수 필드에 따라 달라진다.
<img width="436" alt="스크린샷 2024-06-05 오후 6 01 11" src="https://github.com/junhyeok030213/computer-structure/assets/106813806/67836e19-10ff-468e-ae94-b5e3dab6eab8">

># ALU 제어
## Opcode에서 파생된 2비트 ALUOp를 가정한다.
- 조합 논리로 ALU 제어 유도
<img width="617" alt="스크린샷 2024-06-06 오후 2 39 24" src="https://github.com/junhyeok030213/computer-structure/assets/106813806/f990db71-7e6b-465e-87d1-46b1dd9a4bf1">

># 주 제어 장치
## 명령에서 파생된 제어 신호
<img width="494" alt="스크린샷 2024-06-06 오후 2 41 38" src="https://github.com/junhyeok030213/computer-structure/assets/106813806/d70485cf-573c-4a16-9a41-96e7988e95d0">

># 제어 기능이 있는 데이터 경로
<img width="618" alt="스크린샷 2024-06-06 오후 2 43 07" src="https://github.com/junhyeok030213/computer-structure/assets/106813806/51254362-c84a-45d3-83a7-8088718b0135">

># R-타입 명령어
<img width="509" alt="스크린샷 2024-06-06 오후 2 44 32" src="https://github.com/junhyeok030213/computer-structure/assets/106813806/9da28ab5-8794-4a7c-aebb-d13f14665323">

># 로드 명령어
<img width="501" alt="스크린샷 2024-06-06 오후 2 44 56" src="https://github.com/junhyeok030213/computer-structure/assets/106813806/090212bd-23d2-4fd3-85a1-b515e086be53">

># 브랜치 온 이퀄(Branch-on-Equal) 명령어
<img width="560" alt="스크린샷 2024-06-06 오후 2 45 39" src="https://github.com/junhyeok030213/computer-structure/assets/106813806/3fab7044-0a27-411e-adba-4efff8a3a70e">

># 점프 구현
<img width="601" alt="스크린샷 2024-06-06 오후 2 46 08" src="https://github.com/junhyeok030213/computer-structure/assets/106813806/22a285dd-dcb8-4af5-bd62-03f33bccb2b3">

## Jump는 단어 주소를 사용한다.
## 다음을 연결하여 PC 업데이트
- (PC + 4)의 상위 4비트
- 26비트 점프 주소
- 00
## Opcode에서 디코딩된 추가 제어 신호가 필요하다.

># 점프가 추가된 데이터 경로
<img width="568" alt="스크린샷 2024-06-06 오후 2 49 12" src="https://github.com/junhyeok030213/computer-structure/assets/106813806/9cb5c4d3-7cd0-463a-a887-cb0fc0433565">

># 성능 문제
## 가장 긴 지연이 클록 주기를 결정한다.
- 중요 경로: 로드 명령
- 명령어 메모리 -> 레지스터 파일 -> ALU -> 데이터 메모리 -> 레지스터 파일
## 다른 지침에 따라 기간을 변경할 수 없음
## 디자인 원칙을 위반함
- 일반적인 경우 빠르게 만듦
## 파이프라이닝을 통해 성능 향상시킬 것임

># 파이프라이닝 유추
## 파이프라이닝 세탁: 중첩 실행
- 병렬화로 성능 향상
## 파이프라이닝된 4개 로드:
- 속도 향상 = 8시간/3.5시간 = 2.3
<img width="364" alt="스크린샷 2024-06-06 오후 3 02 46" src="https://github.com/junhyeok030213/computer-structure/assets/106813806/73509e53-3147-4f95-a5a1-32c27cf6b71d">

## 논스톱:
- 속도 향상(n 명령어) = 2n hr/(0.5n hr + 1.5 hr) ≈ 4 (number of stages)
<img width="363" alt="스크린샷 2024-06-06 오후 3 03 59" src="https://github.com/junhyeok030213/computer-structure/assets/106813806/8c9867b7-21dd-4f84-b62f-cbbd660bbdae">

># MIPS 파이프라인
## 5단계, 각 단계마다 한 단계
- IF: 메모리에서 가져오기 명령어 (Instruction Fetch from memory)
- ID: 명령어 디코드 및 레지스터 읽기 (Instruction Decode & register read)
- EX: 연산 실행 또는 주소 계산 (EXecute operation or calculate address)
- MEM: 메모리 피연산자에 액세스 (acess MEMory operand)
- WB: 결과 쓰기 등록으로 돌아가기 (Write result Back to register)

