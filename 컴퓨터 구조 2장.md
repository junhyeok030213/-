># 명령어 세트
## 컴퓨터 명령의 레퍼토리
## 컴퓨터마다 명령어 세트가 다르다
- 하지만 여러면에서 공통점이 있다
## 초기 컴퓨터에는 매우 간단한 명령어 세트가 있다.
- 단순화된 구현
## 많은 최신 컴퓨터에는 간단한 명령어 세트도 있다.

># MIPS 명령어 세트
## 책 전체에서 예제로 사용됨
## MIPS Technologies에서 상업화한 Standford MIPS(https://www.mips.com/)
## 많은 현대의 전형적인 ISAs(명령어 집합)
- MIPS 참조 데이터 분리 카드와 부록 A 및 E를 참조하여라
## 유사한 ISA가 임베디드 코어 시장에서 큰 점유율을 차지하고 있음.
- 가전제품, 네트워크/스토리지 장비, 카메라, 프린터 등에 적용됨

># 산술 연산
## 덧셈과 뺄셈, 세개의 피연산자
- 소스 2개아 대상 1개
<img width="473" alt="스크린샷 2024-04-11 오후 7 45 32" src="https://github.com/junhyeok030213/computer-structure/assets/106813806/560cf9e0-8069-4206-bcc8-d37f395038dc">

## 모든 산술 연산은 이 형식을 갖는다.
## 디자인 원칙 1: 단순성은 규칙성을 선호한다.
- 규칙성은 구현을 더 간단하게 만든다.
- 단순성을 통해 더 낮은 비용으로 더 높은 성능을 얻을 수 있다.

># 산술 예
## C 코드
<img width="387" alt="스크린샷 2024-04-11 오후 7 51 51" src="https://github.com/junhyeok030213/computer-structure/assets/106813806/1391840e-ff01-4409-a980-8b1971e005d1">

## 컴파일된 MIPS 코드:
<img width="559" alt="스크린샷 2024-04-11 오후 7 52 18" src="https://github.com/junhyeok030213/computer-structure/assets/106813806/25143296-7ce9-40ae-9581-86c0b6f4f423">

># 피연산자 등록
## 산술 명령어는 레지스터 피연산자를 사용한다.

<img width="332" alt="스크린샷 2024-04-11 오후 8 00 21" src="https://github.com/junhyeok030213/computer-structure/assets/106813806/ccd247f4-a27b-4610-abfd-3a7bc01cb652">


## MIPS에는 32*32비트 레지스터 파일이 있다. (자주 사용되는 파일은 레지스터 파일에)
- 자주 액세스하는 데이터에 사용됨.
- 0부터 31번 까지 있음.
- "워드"라고 불리는 32비트 데이터

## Assembler names
- 임시 값의 경우 $t0, $t1, ..., $t9
- 저장된 변수의 경우 $s0, $s1, ..., $s7
## 디자인 원칙 2: 작을수록 빠르다.
- 주 메모리(Main memory): 수백만 개의 위치

># 피연산자 등록 예
## C 코드
<img width="528" alt="스크린샷 2024-04-11 오후 8 02 29" src="https://github.com/junhyeok030213/computer-structure/assets/106813806/a7befec4-e821-4e20-9435-20ad640b3945">

## 컴파일된 MIPS 코드:
<img width="296" alt="스크린샷 2024-04-11 오후 8 02 52" src="https://github.com/junhyeok030213/computer-structure/assets/106813806/712e8c51-ccab-442d-9ee4-fdc28b029f45">

># 메모리 피연산자
## 메인 메모리는 복합 데이터에 사용된다.
- 배열, 구조, 동적 데이터
## 산술 연산을 적용하려면
- 메모리의 값을 레지스터로 로드
- 레지스터 결과를 메모리에 저장

## 메모리는 바이트 주소로 지정된다.
- 각 주소는 8비트 바이트를 식별한다.

## 단어는 메모리에 정렬된다.
- 주소는 4의 배수여야 한다. (워드는 4바이트로 구성된다.)

## MIPS는 Big Endian(빅엔디안) 이다.
- 최상위 바이트(최소 워드 주소)
- Little Endian(리틀엔디안): 최소 주소의 최하위 바이트

># 메모리 구성
## 주소가 있는 대규모 단일 차원 배열로 표시된다.
## 메모리 주소는 배열의 인덱스이다.
## "바이트 주소 지정"은 인덱스가 메모리의 바이트를 가리키는 것을 의미한다.
<img width="188" alt="스크린샷 2024-04-11 오후 8 08 59" src="https://github.com/junhyeok030213/computer-structure/assets/106813806/88ccd2fa-410c-4806-8feb-242c358fde6d">

## 바이트도 좋지만 대부분의 데이터 항목은 더 큰 "단어"를 사용한다.
## MIPS의 경우 단어는 32비트 또는 4바이트이다.
<img width="194" alt="스크린샷 2024-04-11 오후 8 10 31" src="https://github.com/junhyeok030213/computer-structure/assets/106813806/f2516d5e-ce1f-494c-80bb-a4d7bc63d49f">
<img width="407" alt="스크린샷 2024-04-11 오후 8 10 43" src="https://github.com/junhyeok030213/computer-structure/assets/106813806/51dc6a2f-fe24-4eed-81ba-32b8560f4bec">

## 0부터 2^(32-1)까지의 바이트 주소를 갖는 2^32 바이트
## 바이트 주소가 0,4,8, ... , 2^32 - 4인 2^30개 단어
- 단어가 정렬된다.
- 워드 주소의 상위 2비트는 00이다.

># 엔디안(객체 주소 지정)
## A93C10CF(16)의 4바이트 워드가 주소 4에서 시작하는 메모리 블럭에 저장되어 있다고 가정하자.
<img width="510" alt="스크린샷 2024-04-11 오후 8 16 59" src="https://github.com/junhyeok030213/computer-structure/assets/106813806/7ebffefa-9610-49fa-a529-f390182ff027">

># 메모리 피연산자 예 1
## C 코드
<img width="500" alt="스크린샷 2024-04-11 오후 8 18 03" src="https://github.com/junhyeok030213/computer-structure/assets/106813806/6782dc30-8b81-4aa5-a459-569925f5981d">

## 컴파일된 MIPS 코드:
- 인덱스 8에는 오프셋 32가 필요하다 ( = 8워드 x 4바이트/워드)
<img width="667" alt="스크린샷 2024-04-11 오후 8 19 57" src="https://github.com/junhyeok030213/computer-structure/assets/106813806/71190c71-2ba3-416c-bb1a-d2a4748da7fe">

