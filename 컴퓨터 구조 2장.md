># 명령어 세트
## 컴퓨터 명령의 레퍼토리
## 컴퓨터마다 명령어 세트가 다르다
- 하지만 여러면에서 공통점이 있다
## 초기 컴퓨터에는 매우 간단한 명령어 세트가 있다.
- 단순화된 구현
## 많은 최신 컴퓨터에는 간단한 명령어 세트도 있다.

># MIPS 명령어 세트
## 책 전체에서 예제로 사용됨
## MIPS Technologies에서 상업화한 Standford MIPS(https://www.mips.com/)
## 많은 현대의 전형적인 ISAs(명령어 집합)
- MIPS 참조 데이터 분리 카드와 부록 A 및 E를 참조하여라
## 유사한 ISA가 임베디드 코어 시장에서 큰 점유율을 차지하고 있음.
- 가전제품, 네트워크/스토리지 장비, 카메라, 프린터 등에 적용됨

># 산술 연산
## 덧셈과 뺄셈, 세개의 피연산자
- 소스 2개아 대상 1개
<img width="473" alt="스크린샷 2024-04-11 오후 7 45 32" src="https://github.com/junhyeok030213/computer-structure/assets/106813806/560cf9e0-8069-4206-bcc8-d37f395038dc">

## 모든 산술 연산은 이 형식을 갖는다.
## 디자인 원칙 1: 단순성은 규칙성을 선호한다.
- 규칙성은 구현을 더 간단하게 만든다.
- 단순성을 통해 더 낮은 비용으로 더 높은 성능을 얻을 수 있다.

># 산술 예
## C 코드
<img width="387" alt="스크린샷 2024-04-11 오후 7 51 51" src="https://github.com/junhyeok030213/computer-structure/assets/106813806/1391840e-ff01-4409-a980-8b1971e005d1">

## 컴파일된 MIPS 코드:
<img width="559" alt="스크린샷 2024-04-11 오후 7 52 18" src="https://github.com/junhyeok030213/computer-structure/assets/106813806/25143296-7ce9-40ae-9581-86c0b6f4f423">

># 피연산자 등록
## 산술 명령어는 레지스터 피연산자를 사용한다.

<img width="332" alt="스크린샷 2024-04-11 오후 8 00 21" src="https://github.com/junhyeok030213/computer-structure/assets/106813806/ccd247f4-a27b-4610-abfd-3a7bc01cb652">


## MIPS에는 32*32비트 레지스터 파일이 있다. (자주 사용되는 파일은 레지스터 파일에)
- 자주 액세스하는 데이터에 사용됨.
- 0부터 31번 까지 있음.
- "워드"라고 불리는 32비트 데이터

## Assembler names
- 임시 값의 경우 $t0, $t1, ..., $t9
- 저장된 변수의 경우 $s0, $s1, ..., $s7
## 디자인 원칙 2: 작을수록 빠르다.
- 주 메모리(Main memory): 수백만 개의 위치

># 피연산자 등록 예
## C 코드
<img width="528" alt="스크린샷 2024-04-11 오후 8 02 29" src="https://github.com/junhyeok030213/computer-structure/assets/106813806/a7befec4-e821-4e20-9435-20ad640b3945">

## 컴파일된 MIPS 코드:
<img width="296" alt="스크린샷 2024-04-11 오후 8 02 52" src="https://github.com/junhyeok030213/computer-structure/assets/106813806/712e8c51-ccab-442d-9ee4-fdc28b029f45">

># 메모리 피연산자
## 메인 메모리는 복합 데이터에 사용된다.
- 배열, 구조, 동적 데이터
## 산술 연산을 적용하려면
- 메모리의 값을 레지스터로 로드
- 레지스터 결과를 메모리에 저장

## 메모리는 바이트 주소로 지정된다.
- 각 주소는 8비트 바이트를 식별한다.

## 단어는 메모리에 정렬된다.
- 주소는 4의 배수여야 한다. (워드는 4바이트로 구성된다.)

## MIPS는 Big Endian(빅엔디안) 이다.
- 최상위 바이트(최소 워드 주소)
- Little Endian(리틀엔디안): 최소 주소의 최하위 바이트

># 메모리 구성
## 주소가 있는 대규모 단일 차원 배열로 표시된다.
## 메모리 주소는 배열의 인덱스이다.
## "바이트 주소 지정"은 인덱스가 메모리의 바이트를 가리키는 것을 의미한다.
<img width="188" alt="스크린샷 2024-04-11 오후 8 08 59" src="https://github.com/junhyeok030213/computer-structure/assets/106813806/88ccd2fa-410c-4806-8feb-242c358fde6d">

## 바이트도 좋지만 대부분의 데이터 항목은 더 큰 "단어"를 사용한다.
## MIPS의 경우 단어는 32비트 또는 4바이트이다.
<img width="194" alt="스크린샷 2024-04-11 오후 8 10 31" src="https://github.com/junhyeok030213/computer-structure/assets/106813806/f2516d5e-ce1f-494c-80bb-a4d7bc63d49f">
<img width="407" alt="스크린샷 2024-04-11 오후 8 10 43" src="https://github.com/junhyeok030213/computer-structure/assets/106813806/51dc6a2f-fe24-4eed-81ba-32b8560f4bec">

## 0부터 $2^{32}-1$까지의 바이트 주소를 갖는 $2^{32}$ 바이트
## 바이트 주소가 0,4,8, ... , $2^{32}$ - 4인 $2^{30}$개 단어
- 단어가 정렬된다.
- 워드 주소의 상위 2비트는 00이다.

># 엔디안(객체 주소 지정)
## A93C10CF(16)의 4바이트 워드가 주소 4에서 시작하는 메모리 블럭에 저장되어 있다고 가정하자.
<img width="510" alt="스크린샷 2024-04-11 오후 8 16 59" src="https://github.com/junhyeok030213/computer-structure/assets/106813806/7ebffefa-9610-49fa-a529-f390182ff027">

># 메모리 피연산자 예 1
## C 코드
<img width="500" alt="스크린샷 2024-04-11 오후 8 18 03" src="https://github.com/junhyeok030213/computer-structure/assets/106813806/6782dc30-8b81-4aa5-a459-569925f5981d">

## 컴파일된 MIPS 코드:
- 인덱스 8에는 오프셋 32가 필요하다 ( = 8워드 x 4바이트/워드)
<img width="667" alt="스크린샷 2024-04-11 오후 8 19 57" src="https://github.com/junhyeok030213/computer-structure/assets/106813806/71190c71-2ba3-416c-bb1a-d2a4748da7fe">

># 메모리 피연산자 예 2
## C 코드
<img width="404" alt="스크린샷 2024-04-11 오후 8 20 47" src="https://github.com/junhyeok030213/computer-structure/assets/106813806/a435fce7-8863-4679-87ca-8530224c55d2">

## 컴파일된 MIPS 코드:
- 인덱스 8에는 오프셋 32가 필요하다.
<img width="701" alt="스크린샷 2024-04-11 오후 8 21 38" src="https://github.com/junhyeok030213/computer-structure/assets/106813806/0e315fb3-b7ca-4cfa-8a9c-d77212e85e5f">

># 레지스터와 메모리
## 레지스터는 메모리보다 액세스 속도가 빠르다.
## 메모리 데이터에 대한 작업에는 로드와 저장이 필요하다.
- 더 많은 명령을 실행해야 한다.
## 컴파일러는 변수에 대해 가능한 한 레지스터를 사용해야 한다.
- 덜 자주 사용되는 변수에 대해서만 메모리로 유출된다.
- 레지스터 최적화가 중요하다!!!

># 직접 피연산자
## 명령어에 지정된 상수 데이터
<img width="635" alt="스크린샷 2024-04-11 오후 8 24 00" src="https://github.com/junhyeok030213/computer-structure/assets/106813806/1b6c6151-07a8-46e0-9747-6b7e0b3a8bd9">

## 뺄셈 즉시 지시 없음
<img width="314" alt="스크린샷 2024-04-11 오후 8 26 50" src="https://github.com/junhyeok030213/computer-structure/assets/106813806/42a7b981-3a09-4b17-b694-4c760a7917e5">

<img width="790" alt="스크린샷 2024-04-11 오후 8 27 42" src="https://github.com/junhyeok030213/computer-structure/assets/106813806/c5d3a6e1-b241-45c2-b4f4-32fc2abe9978">


## 디자인 원칙 3: 일반적인 사례를 빠르게 만든다.
- 작은 상수가 일반적이다.
- 직접 피연산자는 로드 명령을 피한다.

># 상수 제로
## MIPS 레지스터 0($zero)은 상수 0이다.
- 덮어쓸 수 없다.

## 일반적인 작업에 유용
- 레지스터 간 이동
<img width="297" alt="스크린샷 2024-04-11 오후 8 29 42" src="https://github.com/junhyeok030213/computer-structure/assets/106813806/fbc5de07-df48-49a0-9b83-e5f9cd1b2bc6">

># 부호 없는 이진 정수
## n비트 숫자가 주어지면
<img width="525" alt="스크린샷 2024-04-11 오후 8 30 31" src="https://github.com/junhyeok030213/computer-structure/assets/106813806/dd7b9d76-e713-41ee-9c05-ce7b49bcdec9">

## 범위: 0 ~ $2^n - 1$
<img width="541" alt="스크린샷 2024-04-11 오후 8 31 11" src="https://github.com/junhyeok030213/computer-structure/assets/106813806/12ee1e7f-eee2-44d9-9088-29e34bc542e4">

># 부호 있는 숫자에 대한 가능한 표현
<img width="1086" alt="스크린샷 2024-04-11 오후 8 37 05" src="https://github.com/junhyeok030213/computer-structure/assets/106813806/75d55328-a4f2-43b8-8649-170f20de1209">

<img width="311" alt="스크린샷 2024-04-11 오후 8 38 07" src="https://github.com/junhyeok030213/computer-structure/assets/106813806/e44bf25e-298b-4cf2-b97c-68a22f40f301">

## 문제
- 잔액, 0의 수, 조작 용이성
## 2의 보수 표현이 최고다!!

># 2의 보수 부호 있는 정수
<img width="837" alt="스크린샷 2024-04-11 오후 8 41 11" src="https://github.com/junhyeok030213/computer-structure/assets/106813806/48a01613-8f4e-4993-9253-569be3adaba4">

## 비트 31은 부호비트이다.
- 음수의 경우 1
- 음수가 아닌 숫자의 경우 0

## 음수가 아닌 숫자는 동일한 부호 없는 표현과 2의 보수 표현을 갖는다.
## 일부 특정 숫자
<img width="781" alt="스크린샷 2024-04-11 오후 8 44 02" src="https://github.com/junhyeok030213/computer-structure/assets/106813806/d3e2bf8e-3938-4e17-bd30-ebe4c5906bc3">

># 음수화
## 1을 보완하고 더하기
- 보수는 1 -> 0, 0 -> 1을 의미합니다.
<img width="625" alt="스크린샷 2024-04-11 오후 8 47 32" src="https://github.com/junhyeok030213/computer-structure/assets/106813806/1c70bcb7-d455-476d-97f4-e68f758d2923">

<img width="520" alt="스크린샷 2024-04-11 오후 8 48 24" src="https://github.com/junhyeok030213/computer-structure/assets/106813806/4c5d0c63-4865-48c9-8fd8-ac51e968fa99">

## 4비트를 사용하여 2의 보수 표기법으로 -6 코딩ㅇ
<img width="928" alt="스크린샷 2024-04-12 오후 12 52 45" src="https://github.com/junhyeok030213/computer-structure/assets/106813806/a8eebbff-cf73-4cde-a0a5-30d91990d5d6">

># 부호 확장
## 더 많은 비트를 사용하여 숫자 표현
- 숫자 값 유지
## MIPS 명령어 세트
- addi: 즉각적인 가치 확장
- lb, lh: 로드된 바이트/하프워드 확장
- beq, bne: 변위 확장
## 부호 비트를 왼쪽으로 복제
- 부호 없는 값: 0s로 확장
## 예) 8비트에서 16비트로
<img width="439" alt="스크린샷 2024-04-12 오후 12 58 16" src="https://github.com/junhyeok030213/computer-structure/assets/106813806/53b1708d-baa7-48c8-af1d-80a331468df3">

># 기계 코드
## 명령어는 바이너리로 인코딩 된다
- 호출되는 기계어 코드
## MIPS 지침
- 32비트 명령어로 인코딩됨
- 연산코드(opcode), 레지스터 번호 등을 인코딩하는 소수의 형식...
- 규칙성!
## 레지스터 번호
- $t0 ~ $t7은 8 ~ 15에 등록되어있다.
- $t8 ~ $t9은 24 ~ 15에 등록되어있다.
- $s0 ~ $s7은 16 ~ 23에 등록되어있다..

># MIPS R-형식 명령어들
<img width="542" alt="스크린샷 2024-04-14 오후 1 09 44" src="https://github.com/junhyeok030213/computer-structure/assets/106813806/bdae48da-d0bb-4699-8593-64bc7a2490b8">

## 명령어들
- op: 작업 코드(opcode)
- rs: 첫 번째 소스 레지스터 번호
- rt: 두 번쩨 소스 레지스터 번호
- rd: 대상 레지스터 번호
- shamt: 이동량(현재는 00000)
- funct: 함수 코드(opcode 확장)

># R-형식 예
<img width="666" alt="스크린샷 2024-04-14 오후 1 13 23" src="https://github.com/junhyeok030213/computer-structure/assets/106813806/e85a57d4-be94-421b-8c92-d0bfd9a720a0">

># 16진수 표현
## Base 16
- 비트열의 간결한 표현
- 16진수당 4비트
<img width="495" alt="스크린샷 2024-04-14 오후 1 16 30" src="https://github.com/junhyeok030213/computer-structure/assets/106813806/e0845971-7fc5-47fd-b302-f25a69c8c2c3">

## 예) eca8 6420
<img width="351" alt="스크린샷 2024-04-14 오후 1 17 03" src="https://github.com/junhyeok030213/computer-structure/assets/106813806/9e24b563-331e-4c9a-bc3f-f84503831a17">

># MIPS I-형식 명령어들
<img width="529" alt="스크린샷 2024-04-14 오후 1 18 02" src="https://github.com/junhyeok030213/computer-structure/assets/106813806/931eeb81-d45a-442f-b4f4-64a6f11939eb">

## 즉각적인 산술 및 로드/저장 명령
- rt: 대상 또는 소스 레지스터 번호
- 상수: $-2^{15}$ ~ $+2^{15} - 1$
- 주소: rs단위로 기본 주소에 오프셋이 추가된다.

## 디자인 원칙 4: 좋은 디자인은 적절한 타협을 요구한다.
- 다른 형식은 디코딩을 복잡하게 만들지만 32비트 명령을 균일하게 허용한다.
- 형식을 최대한 유사하게 유지

># I-형식 예

<img width="630" alt="스크린샷 2024-04-14 오후 1 23 02" src="https://github.com/junhyeok030213/computer-structure/assets/106813806/2eb3e305-1c1f-43a6-9aaa-7b747eb3bed5">

