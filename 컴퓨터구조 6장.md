># 소개
## 목표: 여러 대의 컴퓨터를 연결하여 더 높은 성능을 얻을 수 있습니다
- 멀티프로세서ㅍ
- 확장성, 가용성, 전력 효율성
## 작업 수준(프로세스 수준) 병행
- 독립적인 작업을 위한 높은 처리량
## 병렬처리 프로그램
- 여러 프로세서에서 단일 프로그램 실행
## 멀티코어 마이크로프로세서
- 프로세서(코어)가 여러 개인 칩

># 하드웨어 및 소프트웨어
## 하드웨어
- 직렬: 예: 펜티엄 4
- 병렬: 예: 쿼드 코어 Xeon e5345
## 소프트웨어
- 순차적: 예: 행렬 곱셈
- 동시(concurrent): 운영 체제
## 순차/동시 소프트웨어는 직렬/병렬 하드웨어에서 실행할 수 있습니다.
- 과제: 병렬 하드웨어를 효과적으로 활용

># 병렬 프로그래밍
## 병렬 소프트웨어가 문제입니다.
## 대폭적인 성능 개선이 필요합니다
- 그렇지 않으면 더 빠른 유니프로세서를 사용하는 것이 더 쉽기 때문입니다!
## 애로사항
- 파티셔닝
- 코디네이션
- 통신 오버헤드

># 암달의 법칙
## 순차 부품은 속도 향상을 제한할 수 있습니다.
## 예: 프로세서 100개, 속도 90배 향상?
<img width="293" alt="스크린샷 2024-06-10 오후 10 26 14" src="https://github.com/junhyeok030213/computer-structure/assets/106813806/d920d781-74d5-4360-9a18-a5b42afbe422">

<img width="619" alt="스크린샷 2024-06-10 오후 10 26 36" src="https://github.com/junhyeok030213/computer-structure/assets/106813806/25599c13-0382-4b7d-9d8b-7e3e4d32b11a">

## 순차적인 부품이 원래 시간의 0.1%(0.001)이어야 함

># 스케일링 예제
## 워크로드: 스칼라 합 10개, 매트릭스 합 10×10
- 10개에서 100개의 프로세서로 속도 향상
## 단일 프로세서: Time = (10 + 100) × tadd
## 프로세서 10개
<img width="397" alt="스크린샷 2024-06-10 오후 10 29 55" src="https://github.com/junhyeok030213/computer-structure/assets/106813806/bee917c4-8d12-49b4-b864-38be9a77b8f2">

- 속도 향상 = 110/20 = 5.5(잠재력 10의 55%)
## 프로세서 100개
<img width="400" alt="스크린샷 2024-06-10 오후 10 30 58" src="https://github.com/junhyeok030213/computer-structure/assets/106813806/c72002b8-d806-4507-8a43-117580fe030d">

- 속도 향상 = 110/11 = 10(잠재력 100의 10%)
## 부하가 프로세서 간에 균형을 이룰 수 있다고 가정합니다

># 스케일링 예제(계속)
## 매트릭스 크기가 100×100이면?
## 단일 프로세서: Time = (10 + 10000) × t_add
## 프로세서 10개
<img width="428" alt="스크린샷 2024-06-10 오후 10 32 58" src="https://github.com/junhyeok030213/computer-structure/assets/106813806/a7e8d650-c2f1-4824-baf4-a4f07f6ce22e">

- 속도 향상 = 10010/1010 = 9.9(잠재력 10의 99%)
## 프로세서 100개
<img width="427" alt="스크린샷 2024-06-10 오후 10 33 16" src="https://github.com/junhyeok030213/computer-structure/assets/106813806/b324ffba-7704-4dc6-86d4-848226e12d33">

- 속도 향상 = 10010/110 = 91(잠재력 100의 91%)
## 하중균형 가정

># 강력한 스케일링과 약한 스케일링
## 강력한 스케일링: 문제 크기 고정
- 앞의 예에서와 같이
## 약한 스케일링: 프로세서 수에 비례하는 문제 크기
- 프로세서 10개, 매트릭스 10x10

   -> 시간 = 20 × t_add

- 100개의 프로세서, 32x32 매트릭스
<img width="366" alt="스크린샷 2024-06-10 오후 10 35 15" src="https://github.com/junhyeok030213/computer-structure/assets/106813806/21ea4b63-2c33-4873-878a-03b1d14e1fb2">

-> 이 예제의 일정한 성능

># 명령 및 데이터 스트림
## 대체 분류
<img width="261" alt="스크린샷 2024-06-10 오후 10 38 26" src="https://github.com/junhyeok030213/computer-structure/assets/106813806/e1c0791a-2df8-419a-88a4-eed8c9fe591b">
<img width="118" alt="스크린샷 2024-06-10 오후 10 38 44" src="https://github.com/junhyeok030213/computer-structure/assets/106813806/8633852a-9dc9-4dbb-ad58-597a4eecf819">

<img width="598" alt="스크린샷 2024-06-10 오후 10 38 12" src="https://github.com/junhyeok030213/computer-structure/assets/106813806/61da6ae3-4a5b-4e87-a112-c20e6f225ac2">

># SPMD: 단일 프로그램 다중 데이터
- MIMD 컴퓨터의 병렬 프로그램
- 다양한 프로세서에 대한 조건부 코드

