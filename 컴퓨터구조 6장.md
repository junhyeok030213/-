># 소개
## 목표: 여러 대의 컴퓨터를 연결하여 더 높은 성능을 얻을 수 있습니다
- 멀티프로세서ㅍ
- 확장성, 가용성, 전력 효율성
## 작업 수준(프로세스 수준) 병행
- 독립적인 작업을 위한 높은 처리량
## 병렬처리 프로그램
- 여러 프로세서에서 단일 프로그램 실행
## 멀티코어 마이크로프로세서
- 프로세서(코어)가 여러 개인 칩

># 하드웨어 및 소프트웨어
## 하드웨어
- 직렬: 예: 펜티엄 4
- 병렬: 예: 쿼드 코어 Xeon e5345
## 소프트웨어
- 순차적: 예: 행렬 곱셈
- 동시(concurrent): 운영 체제
## 순차/동시 소프트웨어는 직렬/병렬 하드웨어에서 실행할 수 있습니다.
- 과제: 병렬 하드웨어를 효과적으로 활용

># 병렬 프로그래밍
## 병렬 소프트웨어가 문제입니다.
## 대폭적인 성능 개선이 필요합니다
- 그렇지 않으면 더 빠른 유니프로세서를 사용하는 것이 더 쉽기 때문입니다!
## 애로사항
- 파티셔닝
- 코디네이션
- 통신 오버헤드

># 암달의 법칙
## 순차 부품은 속도 향상을 제한할 수 있습니다.
## 예: 프로세서 100개, 속도 90배 향상?
<img width="293" alt="스크린샷 2024-06-10 오후 10 26 14" src="https://github.com/junhyeok030213/computer-structure/assets/106813806/d920d781-74d5-4360-9a18-a5b42afbe422">

<img width="619" alt="스크린샷 2024-06-10 오후 10 26 36" src="https://github.com/junhyeok030213/computer-structure/assets/106813806/25599c13-0382-4b7d-9d8b-7e3e4d32b11a">

## 순차적인 부품이 원래 시간의 0.1%(0.001)이어야 함

># 스케일링 예제
## 워크로드: 스칼라 합 10개, 매트릭스 합 10×10
- 10개에서 100개의 프로세서로 속도 향상
## 단일 프로세서: Time = (10 + 100) × tadd
## 프로세서 10개
<img width="397" alt="스크린샷 2024-06-10 오후 10 29 55" src="https://github.com/junhyeok030213/computer-structure/assets/106813806/bee917c4-8d12-49b4-b864-38be9a77b8f2">

- 속도 향상 = 110/20 = 5.5(잠재력 10의 55%)
## 프로세서 100개
<img width="400" alt="스크린샷 2024-06-10 오후 10 30 58" src="https://github.com/junhyeok030213/computer-structure/assets/106813806/c72002b8-d806-4507-8a43-117580fe030d">

- 속도 향상 = 110/11 = 10(잠재력 100의 10%)
## 부하가 프로세서 간에 균형을 이룰 수 있다고 가정합니다

># 스케일링 예제(계속)
## 매트릭스 크기가 100×100이면?
## 단일 프로세서: Time = (10 + 10000) × t_add
## 프로세서 10개
<img width="428" alt="스크린샷 2024-06-10 오후 10 32 58" src="https://github.com/junhyeok030213/computer-structure/assets/106813806/a7e8d650-c2f1-4824-baf4-a4f07f6ce22e">

- 속도 향상 = 10010/1010 = 9.9(잠재력 10의 99%)
## 프로세서 100개
<img width="427" alt="스크린샷 2024-06-10 오후 10 33 16" src="https://github.com/junhyeok030213/computer-structure/assets/106813806/b324ffba-7704-4dc6-86d4-848226e12d33">

- 속도 향상 = 10010/110 = 91(잠재력 100의 91%)
## 하중균형 가정

># 강력한 스케일링과 약한 스케일링
## 강력한 스케일링: 문제 크기 고정
- 앞의 예에서와 같이
## 약한 스케일링: 프로세서 수에 비례하는 문제 크기
- 프로세서 10개, 매트릭스 10x10

   -> 시간 = 20 × t_add

- 100개의 프로세서, 32x32 매트릭스
<img width="366" alt="스크린샷 2024-06-10 오후 10 35 15" src="https://github.com/junhyeok030213/computer-structure/assets/106813806/21ea4b63-2c33-4873-878a-03b1d14e1fb2">

-> 이 예제의 일정한 성능

># 명령 및 데이터 스트림
## 대체 분류
<img width="261" alt="스크린샷 2024-06-10 오후 10 38 26" src="https://github.com/junhyeok030213/computer-structure/assets/106813806/e1c0791a-2df8-419a-88a4-eed8c9fe591b">
<img width="118" alt="스크린샷 2024-06-10 오후 10 38 44" src="https://github.com/junhyeok030213/computer-structure/assets/106813806/8633852a-9dc9-4dbb-ad58-597a4eecf819">

<img width="598" alt="스크린샷 2024-06-10 오후 10 38 12" src="https://github.com/junhyeok030213/computer-structure/assets/106813806/61da6ae3-4a5b-4e87-a112-c20e6f225ac2">

## SPMD: 단일 프로그램 다중 데이터
- MIMD 컴퓨터의 병렬 프로그램
- 다양한 프로세서에 대한 조건부 코드

># 멀티쓰레드
## 스레드
<img width="200" alt="스크린샷 2024-06-11 오전 1 17 16" src="https://github.com/junhyeok030213/computer-structure/assets/106813806/e2c344f3-5199-4562-be41-1ade141892c7">

- 스레드는 프로세스 내부에 포함됩니다. 동일한 프로세스 내에 여러 스레드가 존재할 수 있고 메모리와 같은 리소스를 공유할 수 있는 반면, 다른 프로세스는 이러한 리소스를 공유하지 않습니다.
## 멀티쓰레드
- 여러 개의 실행 스레드를 병렬로 수행

   -> 레지스터, PC 등을 복제합니다.

   -> 스레드 간 빠른 전환

## 세립형 멀티스레드(Fine-grain multithreading)
- 매 주기 후 스레드 전환
-  인터리브 명령어 실행
- 하나의 스레드가 정지되면 다른 스레드가 실행됩니다.
## 거친 낱알 멀티쓰레드(Coarse-grain multithreading)
- 롱 스톨만 켜짐(예: L2-캐시 미스)
- 하드웨어를 단순화하지만 짧은 스톨(예: 데이터 위험)을 숨기지 않습니다

># 동시 멀티스레딩
## 다중 이슈 동적 스케줄드 프로세서에서,
- 여러 스레드에서 지침 예약
- 함수 단위를 사용할 수 있을 때 독립 스레드의 명령이 실행됩니다.
- 스레드 내에서 종속성은 스케줄링 및 레지스터 이름 변경으로 처리됩니다.
## 예: 인텔 펜티엄-4 HT
- 두 개의 스레드: 중복 레지스터, 공유 기능 유닛 및 캐시

># 멀티스레드 예제
<img width="499" alt="스크린샷 2024-06-11 오전 1 21 33" src="https://github.com/junhyeok030213/computer-structure/assets/106813806/eff8ebec-5fe3-4bf9-a4fc-798db611e242">

># 공유 메모리
## SMP: 공유 메모리 멀티프로세서
- 하드웨어는 모든 프로세서에 단일 물리적 주소 공간을 제공합니다.
- 잠금을 사용하여 공유 변수 동기화
- 메모리 접근 시간

   -> UMA(균일) 대 NUMA(불균일)

<img width="451" alt="스크린샷 2024-06-11 오전 1 22 39" src="https://github.com/junhyeok030213/computer-structure/assets/106813806/0daf2c56-ed31-46c9-96ce-192da69780bd">

># 예: 합계 감소
<img width="269" alt="스크린샷 2024-06-11 오전 1 23 36" src="https://github.com/junhyeok030213/computer-structure/assets/106813806/fdbae8af-8a1b-47a5-86c8-2a14fb55401e">

## 64개 프로세서 UMA에서 64,000개의 숫자 합계
- 각 프로세서의 ID는 0 ≤ P_n ≤ 63 입니다
- 프로세서당 1000개의 파티션 번호
- 각 프로세서의 초기 합계
<img width="380" alt="스크린샷 2024-06-11 오전 1 24 56" src="https://github.com/junhyeok030213/computer-structure/assets/106813806/931bf1a3-2d39-4753-8668-f4195307b492">

## 이제 이러한 부분 합계를 추가해야 합니다
- 감소: 분열과 정복
- 절반의 프로세서가 쌍을 추가한 다음, 4분의 1, …
- 축소 단계 간에 동기화해야 함

># GPU의 역사
## 초기 비디오 카드
- 비디오 출력을 위한 주소 생성이 포함된 프레임 버퍼 메모리
## 3D 그래픽 처리
- 원래 하이엔드 시스템(예: SGI)
- 더 낮은 비용, 더 높은 밀도
- PC 및 게임 콘솔용 3D 그래픽 카드
## 그래픽 처리 장치
- 3D 그래픽 작업을 지향하는 프로세서
- 버텍스/픽셀 처리, 쉐이딩, 텍스처 매핑 및 래스터화

># 시스템 내 그래픽스
<img width="684" alt="스크린샷 2024-06-11 오전 1 26 33" src="https://github.com/junhyeok030213/computer-structure/assets/106813806/31718623-46b5-4be3-b773-6ffcde6933a9">

># GPU 아키텍처
## 처리는 매우 데이터 병렬적입니다.
- GPU는 고도로 멀티 스레드화되어 있습니다
- 스레드 전환을 사용하여 메모리 지연 시간 숨기기

   -> 다단계 캐시에 대한 의존도 감소

- 그래픽 메모리는 넓고 고대역폭입니다
## 범용 GPU를 지향하는 추세
- 이기종 CPU/GPU 시스템
- 순차 코드용 CPU, 병렬 코드용 GPU
## 프로그래밍 언어/API
- DirectX, OpenGL
- C(Cg) 그래픽, HLSL(High Level Shader Language)용
- 컴퓨팅 통합 디바이스 아키텍처(CUDA)

># 예: 엔비디아 GPU
## 여러 개의 SIMD 프로세서, 각각은 다음과 같습니다:
<img width="662" alt="스크린샷 2024-06-11 오전 1 28 33" src="https://github.com/junhyeok030213/computer-structure/assets/106813806/99a1ff6e-4619-445a-aad1-6513252dae87">

># DSAs 도메인별 아키텍처(Domain Specific Architectures)
## GPU와 마찬가지로 DSA는 좁은 범위의 작업만 수행하지만 매우 잘 수행합니다.
## 컴퓨터는 과거의 동종 멀티코어 칩보다 훨씬 더 이질적일 것입니다.
## DSA의 예
- TPU(Google Tensor Processing Unit)(딥 뉴럴 네트워크용) 및 Pixel Visual Core(이미지 처리용)
- Microsoft Catapult(데이터 센터 가속화용)
- Intel Crest(심층 신경망용)

># DSA의 5대 원칙
## DSA는 5가지 원칙을 따릅니다:
1. 전용 메모리를 사용하여 데이터 이동 거리 최소화
2. 고급 마이크로아키텍처 최적화를 통해 절약한 리소스를 더 많은 산술 단위 또는 더 큰 메모리에 투자할 수 있습니다
3. 도메인과 일치하는 가장 쉬운 형태의 병렬을 사용합니다
4. 데이터 크기를 줄이고 도메인에 필요한 가장 간단한 유형으로 입력
5. 도메인별 프로그래밍 언어를 사용하여 DSA로 코드 포팅

># 메시지 전달
## 각 프로세서에는 개인 물리적 주소 공간이 있습니다.
## 하드웨어가 프로세서 간에 메시지를 송수신합니다.
<img width="438" alt="스크린샷 2024-06-11 오전 1 33 57" src="https://github.com/junhyeok030213/computer-structure/assets/106813806/e72a0805-dee5-49e0-800a-2a706171b7d5">

># 느슨하게 결합된 클러스터
## 독립 컴퓨터 네트워크
- 각각 개인 메모리와 OS가 있습니다.
- I/O 시스템을 사용하여 연결됨

   -> 예: 이더넷/스위치, 인터넷

## 독립적인 작업이 있는 응용 프로그램에 적합합니다
- 웹 서버, 데이터베이스, 시뮬레이션...
## 고가용성, 확장성, 경제성
## 문제점
- 관리비
- 낮은 상호 연결 대역폭

   -> Cf. SMP의 프로세서/메모리 대역폭

># 합계 감소(Again)
## 64개 프로세서에서 64,000개 합계
## 먼저, 각각에게 1000개의 숫자를 분배합니다
- 그런 다음 부분합을 합니다
<img width="261" alt="스크린샷 2024-06-11 오전 1 36 19" src="https://github.com/junhyeok030213/computer-structure/assets/106813806/48545dea-f17e-4bd3-828c-68152694001a">

## 감액
- 프로세서의 절반은 보내고 나머지 절반은 받고 추가합니다
- 분기 전송, 분기 수신 및 추가...

># 그리드 컴퓨팅
## 장거리 네트워크로 상호 연결된 별도의 컴퓨터
- 예: 인터넷 연결
- 작업 단위를 파밍하고 결과를 다시 보냅니다
## PC의 유휴 시간을 활용할 수 있습니다
- 예: SETI@home, World Community Grid

># 상호접속망
## 네트워크 토폴로지
- 프로세서, 스위치 및 링크의 배열
<img width="535" alt="스크린샷 2024-06-11 오전 1 37 49" src="https://github.com/junhyeok030213/computer-structure/assets/106813806/b445b333-1697-41bb-90cf-0b57c40a20b0">

># 다단계 네트워크
<img width="688" alt="스크린샷 2024-06-11 오전 1 38 25" src="https://github.com/junhyeok030213/computer-structure/assets/106813806/a325fea2-19b5-46ed-9893-d6409cfc4712">

># 네트워크 특성
## 실적
- 메시지당 지연 시간(로드되지 않은 네트워크)
- 처리량

   -> 링크 대역폭

   -> 총 네트워크 대역폭

   -> 이등분 대역폭
  
- 정체 지연(트래픽에 따라 다름)
## 비용
## 전력(와트 단위)
## 실리콘의 라우팅성

># 결론 비고
## 목표: 여러 프로세서를 사용하여 성능 향상
## 애로사항
- 병렬 소프트웨어 개발
- 적절한 아키텍처 고안
## SaaS의 중요성은 점점 커지고 있으며 클러스터는 잘 어울립니다.
- SaaS: 서비스형 소프트웨어
## 달러당 성능과 줄당 성능은 모바일 및 창고 규모의 컴퓨터 모두를 구동합니다.
## 컴퓨터 설계자들에게 지속적인 도전!
